#!/bin/sh

set -e

IMAGE_TYPE="@IMAGE_TYPE@"

# sleep a second for devices to settle
sleep 1

# if an alternative init exists, exec it first. This is useful for future
# updates, as the file you're reading right now is inaccessible after k3os
# boots.
if [ -x "/k3os/system/init.preinit" ]; then
	exec /k3os/system/init.preinit
fi

# perform an fsck on the root filesystem
mount -t proc none /proc
mount -t sysfs none /sys

if [ "$IMAGE_TYPE" = "raspberrypi" ]; then
	PARTUUID=$(cat /proc/cmdline | sed -r 's/^.*PARTUUID=([^ ]+).*$/\1/')
	ROOTDEVICE=$(blkid | grep PARTUUID=\"$PARTUUID\" | awk -F: '{print $1}')
elif [ "$IMAGE_TYPE" = "orangepipc2" ]; then
	ROOTDEVICE=$(cat /proc/cmdline | sed -r 's/.*root=([^ ]+) .*/\1/')
fi

EXIT_CODE=0
/sbin/e2fsck -pv $ROOTDEVICE || EXIT_CODE=$?

# If bit 2 is set in the exit code, it means file system errors were corrected
# and the system should be rebooted. However, bit 2 is also set in typical
# shell exit codes like 127 (command not found), so we try to limit ourselves
# to exit codes likely generated by e2fsck itself, to prevent a reboot loop.

if [ "$(( EXIT_CODE & 2))" = "2" -a "$EXIT_CODE" -lt 64 ]; then
	echo "fsck corrected errors in the filesystem - rebooting..."
	sleep 15
	reboot -f
	exit 1
elif [ "$EXIT_CODE" != "0" ]; then
	# Something was corrected or uncorrectable, allow user to read the error before
	# system boots further
	sleep 15
fi

modprobe squashfs || true
exec /sbin/init
